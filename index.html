<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>EMISSIONS per £1m GVA by UK LOCAL AUTHORITY (2015-2023)</title>

  <!-- Leaflet CSS -->
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" crossorigin="anonymous" />
  <!-- Leaflet + PapaParse (defer) -->
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js" defer crossorigin="anonymous"></script>
  <script src="https://unpkg.com/papaparse@5.4.1/papaparse.min.js" defer></script>

  <style>
    :root { --bg:#0b0f19; --panel:#212F47; --text:#e8ecf3; --muted:#c3ccda; --accent:#4f8cff; --border:#2f3e5b; }
 html, body {
  height: 100%;
  margin: 0;
  font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, Arial, sans-serif;
  background: var(--bg);
  color: var(--text);
}

/* --- Header: restore style --- */
header {
  grid-column: 1 / -1;
  padding: 10px 16px;
  border-bottom: 1px solid var(--border);
  background: var(--panel);         /* your navy #212F47 */
  display: flex;
  align-items: center;
  gap: 12px;
}
header h1 {
  margin: 0;
  font-weight: 800;
  font-size: 22px;                  /* restore size */
  letter-spacing: .5px;
  text-transform: uppercase;        /* BIG CAPS */
  color: var(--text);               /* ensure visible on navy */
}
.brand { display: flex; align-items: center; gap: 12px; }
.brand img { width: 40px; height: 40px; border-radius: 50%; border: 2px solid rgba(255,255,255,.08); object-fit: cover; }
.brand .sub { color: var(--muted); font-size: 12px; }

/* --- KPI: restore “Year” box look --- */
.kpis {
  display: grid;
  grid-template-columns: 1fr;       /* one KPI since you removed Matched */
  gap: 10px;
  margin-bottom: 8px;
}
.kpi {
  background: #0e1424;
  border: 1px solid var(--border);
  border-radius: 12px;
  padding: 8px 10px;
}
.kpi .l {
  font-size: 12px;
  color: var(--muted);
  margin-bottom: 4px;
}
.kpi .v {
  font-size: 18px;                  /* bump for emphasis */
  font-weight: 700;
  color: var(--text);
}

#app {
  display: grid;
  grid-template-columns: 360px 1fr;   /* widened sidebar */
  grid-template-rows: auto 1fr;
  height: 100%;
}

/* Ensure the map container actually has height */
main { position: relative; }
#map { height: 100%; width: 100%; min-height: 400px; }

/* Sidebar */
aside {
  border-right: 1px solid var(--border);
  background: var(--panel);
  padding: 14px;
  overflow-y: auto;
  overflow-x: hidden;                 /* no horizontal scroll */
}

/* Header (unchanged from yours) */
header { grid-column: 1 / -1; padding: 10px 16px; border-bottom: 1px solid var(--border); background: var(--panel); display: flex; align-items: center; gap: 12px; }
header h1 { font-size: 22px; letter-spacing: .5px; font-weight: 800; margin: 0; text-transform: uppercase; }
.brand { display: flex; align-items: center; gap: 12px; }
.brand img { width: 40px; height: 40px; border-radius: 50%; border: 2px solid rgba(255,255,255,.08); object-fit: cover; }
.brand .sub { color: var(--muted); font-size: 12px; }

/* Controls */
.group { margin-bottom: 16px; }
.group label { display: block; font-size: 12px; color: var(--muted); margin-bottom: 6px; }

input[type="range"],
input[type="number"],
button,
select {
  width: 100%;
  max-width: 100%;        /* never wider than sidebar */
  box-sizing: border-box;
  background: #0e1424;
  color: var(--text);
  border: 1px solid var(--border);
  border-radius: 10px;
  padding: 8px 10px;
  font-size: 14px;
}
    .legend{position:absolute;bottom:16px;right:16px;background:rgba(20,26,42,.96);border:1px solid var(--border);color:var(--text);padding:10px 12px;border-radius:12px;font-size:12px;line-height:1.2;box-shadow:0 10px 24px rgba(0,0,0,.25);z-index:1000;pointer-events:none}
    .legend .row{display:flex;align-items:center;gap:8px;margin:4px 0}
    .swatch{width:16px;height:12px;border-radius:2px;border:1px solid rgba(255,255,255,.1)}
    .tooltip{background:rgba(20,26,42,.96);border:1px solid var(--border);color:var(--text);padding:10px 12px;border-radius:10px;font-size:12px;box-shadow:0 10px 24px rgba(0,0,0,.25)}
    .note{font-size:12px;color:var(--muted)}
    .kpis{display:grid;grid-template-columns:1fr 1fr;gap:10px;margin-bottom:8px}
    .kpi{background:#0e1424;border:1px solid var(--border);border-radius:12px;padding:8px 10px}
    .kpi .v{font-size:16px;font-weight:600}
    .row-inline{display:flex;gap:8px;align-items:center}
  </style>
</head>
<body>
  <div id="app">
    <header>
      <div class="brand">
        <img src="/data/logo.png" alt="logo" />
        <div>
          <h1>EMISSIONS per £1m GVA by UK LOCAL AUTHORITY (2015-2023)</h1>
          <div class="sub">ONS LAD 2023&#160;·&#160;interactive choropleth</div>
        </div>
      </div>
    </header>

   <aside>
  <div class="group kpis">
    <div class="kpi">
      <div class="l">Year</div>
      <div class="v" id="kpi-year">—</div>
    </div>
  </div>

  <div class="group">
    <label>Year</label>
    <input id="yearRange" type="range" min="2015" max="2023" step="1" value="2023"/>
    <input id="yearInput" type="number" min="2015" max="2023" step="1" value="2023" style="margin-top:6px;"/>
  </div>


    <div class="group">
  <label>Geography</label>
  <select id="geoMode">
    <option value="ITL3" selected>ITL3 regions</option>
    <option value="ITL1">ITL1 regions</option>
  </select>
</div>

  <div class="group">
     <label>Metric</label>
  <select id="metricMode">
    <option value="total" selected>Total GHG (CO₂e)</option>
    <option value="co2">CO₂</option>
    <option value="ch4">CH₄</option>
    <option value="n2o">N₂O</option>
  </select>
</div>


  <div class="group row-inline">
    <button id="playBtn" class="primary" style="flex:1;">▶ Play year</button>
    <button id="fitBtn" class="primary" style="flex:1;">Reset map</button>
  </div>
</aside>


    <main style="position:relative;">
      <div id="map"></div>
      <div id="legend" class="legend"></div>
    </main>
  </div>

<script defer>
  // ========= Paths (adjust if your filenames differ) =========
  const GEO_ITL3_URL = '/data/lad_2023.geojson';              // ITL3 polygons (UK-wide)
  const GEO_ITL1_URL = '/data/itl1_boundaries.geojson';   // ITL1 polygons (UK-wide)
  const CSV_URL      = '/data/data.csv';                  // ITL3-scale data with totals + GVA

  function normITL1(code){
  return String(code || '').trim().toUpperCase();
}
  
  // ========= UI / State =========
  const GOLD_PALETTE = ['#fff7e6','#ffe8b3','#ffd580','#ffc247','#ffae00','#d89000','#b37400','#8c5a00'];
  const NO_DATA_FILL = '#3a4258';

  let map, layer, geoITL3, geoITL1;
  let dataRows = [];
  let year = 2023;
  let geoMode = 'ITL3';       // 'ITL3' | 'ITL1'
  let metricMode = 'total';   // 'total' | 'co2' | 'ch4' | 'n2o'
  let timer = null;
  let yearBounds = [2015, 2023];

  // Detected CSV keys (robust to header variants)
  let CSV_KEYS = { code:null, year:null, total:null, co2:null, ch4:null, n2o:null, gva:null, itl1:null };

  // Feature prop keys (we'll auto-detect once per GeoJSON)
  let ITL3_KEYS = { codeProp:null, nameProp:null };
  let ITL1_KEYS = { codeProp:null, nameProp:null };

  // Fixed breaks by geography & metric: e.g., BREAKS.ITL3.total = [..9 values..]
  const BREAKS = { ITL3:{ total:[], co2:[], ch4:[], n2o:[] }, ITL1:{ total:[], co2:[], ch4:[], n2o:[] } };

  // ========= Init =========
  function init(){
    map = L.map('map', { preferCanvas:true, zoomControl:true, zoomSnap:0.25, zoomDelta:0.5 })
      .setView([54.9, -3.5], 6);

    L.tileLayer('https://{s}.basemaps.cartocdn.com/dark_all/{z}/{x}/{y}{r}.png',
      { attribution:'&copy; OpenStreetMap, &copy; CARTO' }).addTo(map);

    // UI events
    document.getElementById('fitBtn').addEventListener('click', fitUK);
    document.getElementById('playBtn').addEventListener('click', togglePlay);

    document.getElementById('geoMode').addEventListener('change', e=>{
      geoMode = e.target.value;
      swapLayer();
      render();
    });

    document.getElementById('metricMode').addEventListener('change', e=>{
      metricMode = e.target.value;
      render();
    });

    const yrRange = document.getElementById('yearRange');
    const yrInput = document.getElementById('yearInput');
    yrRange.addEventListener('input', e=>{ year = +e.target.value; yrInput.value = year; render(); });
    yrInput.addEventListener('input', e=>{ year = +e.target.value; yrRange.value = year; render(); });

    // Load everything
    Promise.all([loadGeoITL3(), loadGeoITL1(), loadCsv()]).then(()=>{
      computeAllBreaks();   // build fixed scales per (geo, metric)
      swapLayer();
      fitUK();
      render();
    }).catch(err=>{
      console.error(err);
      alert('Failed to load one or more resources.');
    });
  }

  // ========= Loaders =========
  async function loadGeoITL3(){
    const res = await fetch(GEO_ITL3_URL, { cache:'no-store' });
    if(!res.ok) throw new Error('ITL3 GeoJSON fetch failed: '+res.status);
    geoITL3 = await res.json();
    ITL3_KEYS = detectFeatureKeys(geoITL3);
    console.log('ITL3 feature keys:', ITL3_KEYS);
  }

  async function loadGeoITL1(){
  const res = await fetch(GEO_ITL1_URL, { cache:'no-store' });
  if(!res.ok) throw new Error('ITL1 GeoJSON fetch failed: '+res.status);
  geoITL1 = await res.json();

  // Default detection first
  ITL1_KEYS = detectFeatureKeys(geoITL1);

  // Try to find the property whose values look like TLC..TLN
  if (geoITL1.features && geoITL1.features.length){
    const test = (val)=> typeof val === 'string' && /^TL[A-N]$/i.test(val.trim());

    // Score each property by how many features match the TLx pattern
    const props = Object.keys(geoITL1.features[0].properties || {});
    const scores = {};
    for (const p of props){
      let count = 0;
      for (let i=0; i<geoITL1.features.length; i++){
        const v = geoITL1.features[i].properties[p];
        if (test(v)) count++;
        if (i > 50) break; // sample first 50 to be quick
      }
      scores[p] = count;
    }

    // Pick the property with the highest TLx hit count
    let bestProp = null, bestScore = -1;
    for (const [p, s] of Object.entries(scores)){
      if (s > bestScore){ bestScore = s; bestProp = p; }
    }

    if (bestScore > 0){
      ITL1_KEYS.codeProp = bestProp;
    }

    // Try to pick a readable name prop if we can (fallback to existing)
    // Prefer something with 'NM'/'NAME' in it.
    const nameCandidate = props.find(k => /(^|_)NM($|_)/i.test(k) || /name/i.test(k));
    if (nameCandidate) ITL1_KEYS.nameProp = nameCandidate;

    console.log('ITL1 keys (final):', ITL1_KEYS, 'sample props:', geoITL1.features[0].properties);
  }
}


  function loadCsv(){
    return new Promise((resolve, reject)=>{
      Papa.parse(CSV_URL, {
        download:true, header:true, dynamicTyping:true, skipEmptyLines:true,
        complete: (results)=>{
          const rows = (results.data||[]);
          if (!rows.length) { return reject(new Error('CSV parsed but no rows')); }

          CSV_KEYS = detectCsvColumns(rows[0]);
          console.log('Detected CSV columns:', CSV_KEYS);
          if (!CSV_KEYS.code || !CSV_KEYS.year || !CSV_KEYS.total || !CSV_KEYS.co2 || !CSV_KEYS.ch4 || !CSV_KEYS.n2o || !CSV_KEYS.gva || !CSV_KEYS.itl1) {
            return reject(new Error('Missing required CSV columns.'));
          }

          dataRows = rows.filter(r => r[CSV_KEYS.code]!=null && r[CSV_KEYS.year]!=null);
          // Year bounds
          const yrs = [...new Set(dataRows.map(r=> +r[CSV_KEYS.year]))].filter(Number.isFinite).sort((a,b)=>a-b);
          if (yrs.length) {
            yearBounds = [Math.min(...yrs), Math.max(...yrs)];
            const [minY,maxY] = yearBounds;
            const yrRange = document.getElementById('yearRange');
            const yrInput = document.getElementById('yearInput');
            yrRange.min=minY; yrRange.max=maxY; yrInput.min=minY; yrInput.max=maxY;
            if(+yrRange.value<minY || +yrRange.value>maxY){ yrRange.value=maxY; yrInput.value=maxY; year=maxY; }
          }
          console.log(`CSV loaded: ${dataRows.length} rows, years ${yearBounds[0]}–${yearBounds[1]}`);
          resolve();
        },
        error: (err)=> reject(err)
      });
    });
  }

  // ========= Detection utilities =========
  function normaliseKey(k){
    return String(k||'').toLowerCase().replace(/[^a-z0-9]+/g,'')
      .replace(/co₂|co2e/g,'co2').replace(/n20/g,'n2o'); // treat N20 as N2O
  }
  function findKey(candidates, row){
    const keys = Object.keys(row);
    const normMap = new Map(keys.map(k=> [normaliseKey(k), k]));
    for (const cand of candidates){
      const norm = normaliseKey(cand);
      if (normMap.has(norm)) return normMap.get(norm);
    }
    // loose contains
    for (const [nk, orig] of normMap.entries()){
      for (const c of candidates){
        const nc = normaliseKey(c);
        if (nk.includes(nc)) return orig;
      }
    }
    return null;
  }
  function detectCsvColumns(sampleRow){
    const code  = findKey(['code','itl3','itl3cd','itlcode','geogcode','area','areacode'], sampleRow);
    const year  = findKey(['year','yyyy','yr'], sampleRow);
    const total = findKey(['total','totalghg','ghg','ktco2e'], sampleRow);
    const co2   = findKey(['co2'], sampleRow);
    const ch4   = findKey(['ch4','methane'], sampleRow);
    const n2o   = findKey(['n2o','nitrousoxide','n20'], sampleRow); // accepts N20
    const gva   = findKey(['gva','gvacv','gva_chained','gva_volume'], sampleRow);
    const itl1  = findKey(['itl1','itl1cd','itl1code','region'], sampleRow);
    return { code, year, total, co2, ch4, n2o, gva, itl1 };
  }

  function detectFeatureKeys(geojson){
    // Heuristic: pick the first feature and choose the first prop that looks like a code (has letters+digits).
    const f = geojson.features?.[0];
    const props = f?.properties || {};
    const keys = Object.keys(props);
    // Prefer common names
    let codeProp = keys.find(k=>/^ITL.*CD$/i.test(k)) || keys.find(k=>/CODE$/i.test(k)) || keys.find(k=>/CD$/i.test(k)) || keys[0];
    let nameProp = keys.find(k=>/^ITL.*NM$/i.test(k)) || keys.find(k=>/NAME$/i.test(k)) || keys.find(k=>/NM$/i.test(k)) || keys[1] || keys[0];
    return { codeProp, nameProp };
  }

  // ========= Breaks / stats =========
  function getQuantileBreaks(values, k=GOLD_PALETTE.length){
    const v = values.filter(Number.isFinite).slice().sort((a,b)=>a-b);
    if(!v.length) return [];
    const qs = [];
    for(let i=0;i<=k;i++){
      const p = i/k;
      const idx = Math.floor(p*(v.length-1));
      qs.push(v[idx]);
    }
    return qs;
  }

  // Compute fixed breaks per (geo, metric) across ALL years
  function computeAllBreaks(){
    ['ITL3','ITL1'].forEach(g=>{
      ['total','co2','ch4','n2o'].forEach(m=>{
        const vals = getAllRatiosAcrossYears(g, m);
        BREAKS[g][m] = getQuantileBreaks(vals, GOLD_PALETTE.length);
      });
    });
    console.log('Fixed breaks:', BREAKS);
  }

  function getRatiosForYear(geo, metric, y){
  const mKey   = CSV_KEYS[metric];   // 'total'|'co2'|'ch4'|'n2o' → CSV key
  const codeKey= CSV_KEYS.code;      // ITL3 code
  const yearKey= CSV_KEYS.year;
  const gvaKey = CSV_KEYS.gva;
  const itl1Key= CSV_KEYS.itl1;      // ITL1 code in CSV

  if (geo === 'ITL3'){
    const m = new Map();  // ITL3 code -> ratio
    for (const r of dataRows){
      if (+r[yearKey] !== +y) continue;
      const code = String(r[codeKey]).trim();
      const num  = +r[mKey];
      const den  = +r[gvaKey];
      m.set(code, (Number.isFinite(num) && Number.isFinite(den) && den !== 0) ? num/den : NaN);
    }
    return m;
  } else {
    // Aggregate to ITL1: sum numerators/denominators across ITL3 children
    const agg = new Map(); // ITL1 -> {num, den}
    for (const r of dataRows){
      if (+r[yearKey] !== +y) continue;
      const itl1 = normITL1(r[itl1Key]);  // <<< normalise here
      const num  = +r[mKey];
      const den  = +r[gvaKey];
      if (!agg.has(itl1)) agg.set(itl1, {num:0, den:0});
      if (Number.isFinite(num)) agg.get(itl1).num += num;
      if (Number.isFinite(den)) agg.get(itl1).den += den;
    }
    const m = new Map();
    for (const [k, nd] of agg.entries()){
      m.set(k, (nd.den !== 0) ? nd.num/nd.den : NaN);
    }
    return m;
  }
}

  // ========= Ratio builders =========
  // Returns Map(code -> ratio) for chosen geography, metric, year
  function getRatiosForYear(geo, metric, y){
    const mKey = CSV_KEYS[metric];   // 'total'|'co2'|'ch4'|'n2o' → CSV key
    const codeKey = CSV_KEYS.code;
    const yearKey = CSV_KEYS.year;
    const gvaKey  = CSV_KEYS.gva;
    const itl1Key = CSV_KEYS.itl1;

    if (geo === 'ITL3'){
      const m = new Map();
      for (const r of dataRows){
        if (+r[yearKey] !== +y) continue;
        const code = String(r[codeKey]).trim();
        const num = +r[mKey];
        const den = +r[gvaKey];
        m.set(code, (Number.isFinite(num) && Number.isFinite(den) && den !== 0) ? num/den : NaN);
      }
      return m;
    } else { // ITL1 aggregate
      const agg = new Map(); // ITL1 -> {num, den}
      for (const r of dataRows){
        if (+r[yearKey] !== +y) continue;
        const itl1 = String(r[itl1Key]).trim();
        const num = +r[mKey];
        const den = +r[gvaKey];
        if (!agg.has(itl1)) agg.set(itl1, {num:0, den:0});
        if (Number.isFinite(num)) agg.get(itl1).num += num;
        if (Number.isFinite(den)) agg.get(itl1).den += den;
      }
      const m = new Map();
      for (const [k, nd] of agg.entries()){
        m.set(k, (nd.den !== 0) ? nd.num/nd.den : NaN);
      }
      return m;
    }
  }

  // ========= Map helpers =========
  function baseStyle(){ return { color:'#1e2a44', weight:0.6, fillColor:NO_DATA_FILL, fillOpacity:0.9 } }

  function bindFeature(f, l, keys){
    l.on({ mouseover: onHover, mouseout: onOut, click: ()=> map.fitBounds(l.getBounds(), { maxZoom:9 }) });
    l._currentFill = NO_DATA_FILL;
    // no tooltip here; added in render()
  }

  function onHover(e){ const l=e.target; l.setStyle({ weight:2, color:'#ffffff', fillColor:l._currentFill, fillOpacity:1 }); if(l.openTooltip) l.openTooltip(); }
  function onOut(e){ const l=e.target; l.setStyle({ weight:0.6, color:'#1e2a44', fillColor:l._currentFill, fillOpacity:0.9 }); }

  function colorFor(val, breaks){
    if(!Number.isFinite(val) || !breaks.length) return NO_DATA_FILL;
    for(let i=0;i<GOLD_PALETTE.length;i++){
      if(val <= breaks[i+1]) return GOLD_PALETTE[i];
    }
    return GOLD_PALETTE[GOLD_PALETTE.length-1];
  }

  function fmt(x){ return Number.isFinite(x)? x.toFixed(3) : '—'; }

  function metricLabel(){
    switch(metricMode){
      case 'co2': return 'CO₂ (kt CO₂e) per £1m GVA';
      case 'ch4': return 'CH₄ (kt CO₂e) per £1m GVA';
      case 'n2o': return 'N₂O (kt CO₂e) per £1m GVA';
      default:    return 'Total GHG (kt CO₂e) per £1m GVA';
    }
  }

  // ========= Layer swapping =========
  function swapLayer(){
    if(layer) { map.removeLayer(layer); layer = null; }
    if (geoMode === 'ITL3'){
      layer = L.geoJSON(geoITL3, {
        style: baseStyle,
        onEachFeature: (f, l)=> bindFeature(f, l, ITL3_KEYS)
      }).addTo(map);
    } else {
      layer = L.geoJSON(geoITL1, {
        style: baseStyle,
        onEachFeature: (f, l)=> bindFeature(f, l, ITL1_KEYS)
      }).addTo(map);
    }
  }

  // ========= Render =========
 function render(){
  if(!map || !layer) return;
  document.getElementById('kpi-year').textContent = year;

  const breaks = BREAKS[geoMode][metricMode] || [];
  const vals   = getRatiosForYear(geoMode, metricMode, year);

  const keys   = (geoMode==='ITL3') ? ITL3_KEYS : ITL1_KEYS;
  const codeP  = keys.codeProp, nameP = keys.nameProp;

  let matched = 0, total = 0, firstFewMisses = [];

  layer.eachLayer(l=>{
    total++;
    const f    = l.feature;
    const rawC = f.properties[codeP];
    const code = (geoMode==='ITL1') ? normITL1(rawC) : String(rawC).trim();  // <<< normalise ITL1 feature codes
    const name = String(f.properties[nameP]);

    const v    = vals.get(code);
    const fill = colorFor(v, breaks);
    l._currentFill = fill;
    l.setStyle({ fillColor: fill });

    const valTxt = Number.isFinite(v) ? v.toFixed(3) : 'No data';
    l.bindTooltip(
      `<div><strong>${name}</strong><br/><span class="note">${code}</span><br/>${metricLabel()}: <strong>${valTxt}</strong></div>`,
      { sticky:true, opacity:0.95, className:'tooltip' }
    );

    if (Number.isFinite(v)) matched++;
    else if (firstFewMisses.length < 5) firstFewMisses.push({code, name});
  });

  console.log(`Render ${geoMode}/${metricMode} ${year}: matched ${matched} of ${total}`);
  if (matched === 0 && total > 0){
    console.warn('Example unmatched ITL1 codes:', firstFewMisses);
    // Also print a sample of CSV ITL1 codes so you can eyeball:
    const sampleCsv = [...new Set(
      dataRows.filter(r=> +r[CSV_KEYS.year]===+year).map(r=> normITL1(r[CSV_KEYS.itl1]))
    )].slice(0,10);
    console.warn('Sample CSV ITL1 codes for this year:', sampleCsv);
  }

  updateLegend(breaks);
}

  function updateLegend(breaks){
    const el = document.getElementById('legend');
    let html = `<div style="margin-bottom:6px;font-weight:700;text-transform:uppercase;">
      ${metricLabel()} — ${geoMode} (fixed scale, ${yearBounds[0]}–${yearBounds[1]})
    </div>`;
    if(!breaks.length){
      html += `<div class="row"><span class="swatch" style="background:${NO_DATA_FILL}"></span> No data</div>`;
      el.innerHTML = html; return;
    }
    for(let i=0;i<GOLD_PALETTE.length;i++){
      const a = breaks[i], b = breaks[i+1];
      if(a==null || b==null) continue;
      html += `<div class="row"><span class="swatch" style="background:${GOLD_PALETTE[i]}"></span> ${fmt(a)} – ${fmt(b)}</div>`;
    }
    html += `<div class="row"><span class="swatch" style="background:${NO_DATA_FILL}"></span> No data</div>`;
    el.innerHTML = html;
  }

  // ========= Map utils =========
  function fitUK(){
    if (!layer) return;
    const bounds = layer.getBounds();
    const tight = bounds.pad(-0.05);
    map.fitBounds(tight, { padding:[20,20] });
  }

  function togglePlay(){
    const btn = document.getElementById('playBtn');
    if(timer){ clearInterval(timer); timer = null; btn.textContent = '▶ Play year'; return; }
    btn.textContent = '⏸ Pause';
    const [minY, maxY] = yearBounds;
    timer = setInterval(()=>{
      year = (year >= maxY) ? minY : (year + 1);
      document.getElementById('yearRange').value = year;
      document.getElementById('yearInput').value = year;
      render();
    }, 1200);
  }

  window.addEventListener('DOMContentLoaded', init);
</script>
